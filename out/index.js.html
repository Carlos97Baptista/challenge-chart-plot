<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import "../../node_modules/bootstrap/dist/css/bootstrap.min.css";
import React, { createContext, useState } from "react";
import Home from "./Pages/Home";
import { Modal } from "react-bootstrap";
export const StateContext = createContext({});
/**
 * @param {object} Editor Stores the texarea object of the code mirror.
 * @param {boolean} ERROR Informs you if the maximum number of data has been entered.
 * @param {object} chartData dictates the chart values.
 * @return {object}
 */
function App() {
  const [Editor, setEditor] = useState();
  const [ERROR, setERROR] = useState(false);
  const [chartData, setChartData] = useState({
    categories: [0, 5],
    series: [],
  });
  // const [started, setStarted] = useState(false);
  /**
   * @param {string} value is the value taken from the terminal (InputArea)
   * @param {array} DataArray is each line (input object) of the terminal
   * @param {number} dataLimit defines the line boundary of the type given at each interval
   * @param {number} dataUnity counts each line of data entered to the limit
   * @param {boolean} erro Informs you if the maximum number of data has been entered
   * @param {array} select stores the select of the start string
   * @param {array} group stores the group of the start string
   * @param {object} groupedData stores the data extracted from the strings
   * @param {boolean} started defines whether a range was started by the start-up line
   * @param {number} seconds converts the start and stop time difference into seconds
   * @param {string} hours converts the varying seconds into time format
   * @param {string} id defines the combination identifier of the groups
   * @param {object} object object for each group stored in the groupedData variant
   * @param {object} otherValues object referring to each variant of the object
   * @param {array} newChartData sets a new line for the chart
   * @param {object} obj defines the object to be analyzed within the groupedData
   * @param {string} name defines the name of the chart litter
   * @return {object}
   *
   */
  const handleClick = () => {
    var value = Editor.getValue();
    var DataArray = value.replace(/}/g, "}#").split("#");
    var dataLimit = 20;
    var dataUnity = 0;
    var erro = false;
    let select,
      group = [];
    let groupedData = {};
    let started = false;
    DataArray.forEach((val) => {
      val = val
        .replace(/\'/g, '"')
        .replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": ');
      let data = JSON.parse(val);
      switch (data.type) {
        case "start":
          started = true;
          select = data.select;
          group = data.group;

          break;
        case "span":
          let seconds = new Date(data.end - data.begin).getTime() / 1000;
          let hours = new Date(seconds * 1000).toISOString().substr(11, 5);

          setChartData({ ...chartData, categories: [0, hours] });
          break;
        case "data":
          dataUnity += 1;
          if (dataUnity &lt;= dataLimit) {
            let id = "";
            let object = {};

            group.forEach((el, index) => {
              id += (index > 0 ? "_" : "") + data[el].toLowerCase();
            });

            object[id] = {};

            select.forEach((el, index) => {
              let otherValues = (groupedData[id] &amp;&amp; groupedData[id][el]) || [];

              object[id] = { ...object[id], [el]: [...otherValues, data[el]] };
            });
            Object.assign(groupedData, object);
          } else {
            setChartData([]);
            erro = true;
            setERROR(true);
            started = false;
            return;
          }

          break;
        case "stop":
          // { type: "line", data: [4, 5] }
          if (!erro) {
            const newChartData = [];

            Object.keys(groupedData).forEach((key) => {
              const obj = groupedData[key];

              const result = [];

              select.forEach((el) => {
                let name = (key + " " + el).replace(/_/g, " ");

                result.push({
                  name: name,

                  type: "line",
                  data: obj[el],
                });
              });

              newChartData.push(...result);
            });
            dataUnity = 0;
            setChartData({ ...chartData, series: newChartData });
            started = false;
            Editor.clearHistory();
          }
          break;
        default:
          break;
      }

      Editor.setValue(value);
    });
  };
  return (
    &lt;>
      &lt;Modal show={ERROR} onHide={() => setERROR(false)}>
        &lt;Modal.Header closeButton>
          &lt;Modal.Title>Limite de dados atingido&lt;/Modal.Title>
        &lt;/Modal.Header>
        &lt;Modal.Body>
          O limite de linhas do tipo "data" são de até 20 para cada intervelo.
        &lt;/Modal.Body>
      &lt;/Modal>
      &lt;div className="App">
        &lt;StateContext.Provider
          value={{
            chartData,
            setChartData,
            handleClick,
            Editor,
            setEditor,
          }}
        >
          &lt;Home />
        &lt;/StateContext.Provider>
      &lt;/div>
    &lt;/>
  );
}

export default App;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#App">App</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Sun Sep 06 2020 20:59:42 GMT-0300 (GMT-03:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
